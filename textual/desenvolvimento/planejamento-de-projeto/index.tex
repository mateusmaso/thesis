\section{Planejamento de Projeto}

Para um melhor entendimento das etapas de desenvolvimento, é preciso antes conhecer o contexto do problema que deu origem ao processo de idealização, a proposta de modelo e detalhes na especificação da ferramenta baseado no modelo proposto, como interface e fluxo de execução. \\

\textbf{Processo de idealização} \\

De modo a permitir que clientes possam consumir dados remotos, é preciso que haja um meio de buscá-los antes de executar qualquer lógica que dependa deles. Para isso, a solução comumente adotada é a implementação de um código de busca para acesso aos dados em serviços\footnote{
  Infraestrutura distribuída (servidores, banco de dados, etc) que respondem a pedidos de operações oriundas de clientes em forma de requisições de API.
} através de uma rede.

No entanto, para que se possa manter garantia na comunicação, é necessário um contrato de acesso entre o cliente e a interface do serviço. Isso porque, após a implementação do código de busca pelo cliente, qualquer mudança em métodos da API podem colocar em risco a funcionalidade e comprometer a lógica da aplicação. Este contrato é, portanto, representado no modelo de comunicação da figura 17 através de chamadas entre o código de busca do cliente e a API do serviço.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client) at (-3,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[right of=client] (clientFetchCode) at (-2.2,0.7) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=clientFetchCode, node distance=1.6cm] (clientLogicCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[rectangle,minimum width=0.8cm, minimum height=3cm,draw,right of=clientFetchCode, node distance=3.0cm] (api) {$API$};
    \node[right of=api, node distance=1.8cm] (server) {\includegraphics[width=1.0cm]{figuras/server}};
    \node[below of=server, node distance=1.8cm] (datastore) {\includegraphics[width=1.0cm]{figuras/database}};
    \node[above of=server, node distance=1.8cm] (data) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[cloud, cloud puffs=30, minimum width=11cm, minimum height=10cm, draw,style={scale=0.6}] (service) at (server) {};
    \node[below of=clientFetchCode,node distance=0.0cm] {\textless$fetch$\textgreater};
    \node[below of=clientLogicCode,node distance=0.0cm] {\textless$logic$\textgreater};
    \node[below of=data,node distance=0.0cm] {\{$data$\}};
    \node[below of=service,node distance=3.6cm] {$Service$};
    \node[below of=client,node distance=1.8cm] {\ldots};
    \node[right of=server,node distance=1.8cm] {\ldots};
    \draw[decorate,decoration={brace,raise=0.2cm,mirror}] ([yshift=6pt]clientFetchCode.north west) -- ([yshift=-12pt]clientLogicCode.south west);
    \draw [->] ([yshift=0.25cm]clientFetchCode.east) -- ([yshift=0.25cm]api.west);
    \draw [->] (api) -- (clientFetchCode);
  \end{tikzpicture}
  \caption{Modelo de comunicação entre cliente e serviço}
\end{figure}

O modelo de comunicação representado pode não revelar possíveis problemas para serviços com pouca demanda de dados e diversidade de clientes. Contudo, ao longo do tempo, com o aumento na quantidade de contratos, mudanças podem se tornar difíceis, como, por exemplo, as de fluxo de dados\footnote{
  Fluxo de acesso por clientes em busca de dados sobre APIs de serviços.
} nas interfaces de acesso.

Mudanças no fluxo de dados são inevitáveis em aplicações distribuídas. Elas ocorrem para abraçar a constante transformação na demanda de dados por clientes. Com isso, busca-se manter uma comunicação eficiente, com redução no número de chamadas executadas na API e do tamanho de dados transmitidos pela rede. Essas mudanças podem ser desde uma simples alteração no nome de um método ou número argumentos, até as mais complexas, como dados de retorno e estilo de arquitetura. A figura 18 ilustra o fluxo de dados entre um cliente e um serviço.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \draw (-2,0) -- (-2,-5) (2,0) -- (2,-5);
    \node at (-2,0.3) {Client};
    \node at (2,0.3) {API (Service)};
    \node[loosely dotted] (virtualData) at (-4,-1){\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=virtualData,node distance=0.0cm] {\{$data$\}};
    \node (data) at (-4,-4.5) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=data,node distance=0.0cm] {\{$data$\}};
    \node[cloud, cloud puffs=16,draw,minimum height=1.2cm] (cloudData) at (4,-2.5) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=cloudData,node distance=0.0cm] {\{$data$\}};
    \draw[->] (-2,-1) -- node[midway,above] {$request$} (2,-1.5);
    \draw[<-] (-2,-2.5) -- node[midway,above] {$response$} (2,-2);
    \draw[->] (-2,-3) -- node[midway,above] {$request$} (2,-3.5);
    \draw[<-] (-2,-4.5) -- node[midway,above] {$response$} (2,-4);
  \end{tikzpicture}
  \caption{Fluxo de dados entre cliente e API}
\end{figure}

Felizmente, o impacto nos clientes das mudanças no fluxo de dados de uma API é previsível, pois afeta diretamente, em sua maioria, o código de busca. Por outro lado, mudanças como a alteração de campos nas estruturas de dados, como renomear um campo "nome" para "nome\_completo", são de um grau de complexidade maior, pois seu impacto pode não influenciar o código de busca e sim a lógica da aplicação, onde é bem mais difícil debugar.

Com o objetivo de viabilizar um novo modelo de comunicação a fim de evitar o impacto no código de busca em clientes devido a mudanças no fluxo de dados, fez-se necessário solucionar os seguintes problemas descritos na tabela 5. \\

\begin{table}[H]
  \begin{tabularx}{\linewidth}{>{\parskip1ex}X@{\kern4\tabcolsep}>{\parskip1ex}X}
    \toprule
    \hfil\bfseries Problema
    &
    \hfil\bfseries Solução
    \\\cmidrule(r{3\tabcolsep}){1-1}\cmidrule(l{-\tabcolsep}){2-2}

    (1) Garantir que não haja criação de contrato entre código de busca e API.\par
    (2) Realizar mudanças no fluxo de dados de uma API sem interferir no código de busca dos clientes.\par
    (3) Encontrar uma forma de expressar requisições entre o cliente e o intermediador.\par
    (4) Mapear consultas no intermediador em requisições para API de serviços.\par

    &

    (1) Construir um intermediador responsável por manter a comunicação entre cliente e serviço.\par
	(2) Evitar que clientes escrevam código de busca voltado à especificação da API, e sim para o intermediador.\par
    (3) Usar uma linguagem de consulta para expressar dependência de dados.\par
    (4) Analisar dependência de dados e formas de acesso através de metadados da API de serviços.\par

\\\bottomrule
  \end{tabularx}
  \caption{Problema-solução na concepção do novo modelo}
\end{table}

\textbf{Proposta de modelo} \\

Um novo modelo é proposto a fim de melhorar a comunicação cliente-servidor apresentada. Observado na figura 19, este prevê a criação de uma ferramenta no cliente para a intermediação da comunicação entre o código de busca e API de serviços. Além disso, há a necessidade de reimplementação do código de busca para uma nova linguagem de consulta que seja interpretada pelo intermediador. Da mesma forma, soma-se a criação de um arquivo no serviço para descrição de metadados da API e outro no cliente para configuração, ambos essenciais para o funcionamento do intermediador.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client) at (-3,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[right of=client] (clientFetchCode) at (-2.2,0) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=clientFetchCode, node distance=1.6cm] (clientLogicCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[above of=clientFetchCode, node distance=1.6cm] (clientConfigCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[rectangle,draw,right of=clientFetchCode,minimum height=1cm,node distance=2.0cm] (broker) {$Broker$};
    \node[rectangle,minimum width=0.8cm, minimum height=3cm,draw,node distance=1.8cm,right of=broker,node distance=2.7cm] (api) {$API$};
    \node[right of=api, node distance=1.8cm] (data) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=data,node distance=1.8cm] (server) {\includegraphics[width=1.0cm]{figuras/server}};
    \node[above of=data, node distance=1.8cm] (metadata) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[cloud, cloud puffs=30, minimum width=11cm, minimum height=10cm, draw,style={scale=0.6}] (service) at (data) {};
    \node[below of=clientFetchCode,node distance=0.0cm] {\textless$fetch$\textgreater};
    \node[below of=clientLogicCode,node distance=0.0cm] {\textless$logic$\textgreater};
    \node[below of=clientConfigCode,node distance=0.0cm] {\textless$config$\textgreater};
    \node[below of=metadata,node distance=0.0cm] {\{$metadata$\}};
    \node[below of=data,node distance=0.0cm] {\{$data$\}};
    \node[below of=service,node distance=3.6cm] {$Service$};
    \node[below of=client,node distance=1.8cm] {\vdots};
    \node[right of=data,node distance=1.8cm] {\ldots};
    \draw[decorate,decoration={brace,raise=0.2cm,mirror}] ([yshift=6pt]clientConfigCode.north west) -- ([yshift=-12pt]clientLogicCode.south west);
    \draw [->] ([yshift=0.25cm]clientFetchCode.east) -- ([yshift=0.25cm]broker.west);
    \draw [->] (broker) -- (clientFetchCode);
    \draw [->] ([yshift=0.25cm]broker.east) -- ([yshift=0.25cm]api.west);
    \draw [->] (api) -- (broker);
    \draw [->,dashed] (clientConfigCode) -| ([xshift=-0.25cm]broker.north);
    \draw [->,dashed] (metadata) -| ([xshift=0.25cm]broker.north);
  \end{tikzpicture}
  \caption{Modelo proposto para evitar contrato de comunicação}
\end{figure}

(Arrumar) A proposta de eliminação de contrato visa também automatizar o acesso de clientes em APIs na busca de dados através da implementação de algoritmos na ferramenta. Dessa maneira, escolhe-se o caminho de acesso de melhor custo benefício em relação aos serviços disponíveis para o cliente. O modelo proporciona, além disso, um ambiente escalável para a composição de dados através de serviços, visto na figura 20.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client1) at (-2,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node (client2) at (2,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[rectangle,draw,minimum height=2cm,minimum width=3cm,below of=client2,node distance=2.3cm] (tool) {$Tool$};
    \node[cloud, cloud puffs=16, draw] (service1) at (-3,-6) {$Service_1$};
    \node (serviceDots) at (0,-6) {\ldots};
    \node[cloud, cloud puffs=16,minimum height=1cm, draw] (serviceN) at (3,-6) {$Service_N$};
    \draw [->] (client1) -- (service1) node [midway,above,font=\footnotesize] {$request$};
    \draw [->] (client1) -- (serviceN) node [midway,above,font=\footnotesize] {$request$};
    \draw [->] (client2) -- (tool) node [midway,above,font=\footnotesize] {$query$};
    \draw [->] (tool) -- (service1) node [midway,above,font=\footnotesize] {$request$};
    \draw [->] (tool) -- (serviceN) node [midway,above,font=\footnotesize] {$request$};
  \end{tikzpicture}
  \caption{(Arrumar) Composição de serviços através da ferramenta do modelo}
\end{figure}

\textbf{Especificação de ferramenta com base no modelo proposto} \\

Visando a aceitação da ferramenta prevista pelo modelo em ambientes de desenvolvimento de clientes, foi preciso pensar em uma especificação que apresentasse uma interface de baixa curva de aprendizagem, um fluxo de execução replicável e agnóstico à plataforma, além do baixo impacto na base de código de clientes. Por conseguinte, a ferramenta proposta foi desenvolvida pensando na reutilização de tecnologias promissoras ou bem consolidadas no mercado de desenvolvimento.

Após um estudo, a primeira escolha foi em utilizar a tecnologia GraphQL como principal solução para intermediação na comunicação. Além de promover o seu uso, GraphQL é a base para os demais fluxos de execução da ferramenta e possibilita que clientes escrevam um código de busca que não fique preso a uma interface de acesso. Da mesma forma, buscou-se trabalhar com formatos abertos de descrição de metadados de APIs, como por exemplo o JSON Hyper-Schema. Através de adaptadores, a ferramenta permite acelerar a integração de serviços que já oferecem metadados em formatos suportados.

A seguir, é realizada a análise dos dois fluxos de execução descritos na especificação da ferramenta. O primeiro, figura 21, é o processo de criação do intermediador, que recebe como entrada funções de configuração de serviços e retorna um esquema GraphQL. O segundo, figura 22, é o processo de consulta de dados no intermediador, onde leva como entrada consultas escritas na sintaxe da linguagem GraphQL e, após chamadas à APIs, retorna estruturas de dados JSON.

\begin{enumerate}[noitemsep]
  \item \textbf{Construir esquema para serviço}: (Arrumar) Serve para criar um esquema GraphQL para os metadados do serviço. Este processo pode ser sobrescrito por adaptadores.
  \item \textbf{Envolver campos de esquema}: (Arrumar) Serve para fazer X. Um exemplo seria Y.
  \item \textbf{Unificar esquemas}: (Arrumar) Serve para produzir um esquema unificado, utilizado para interpretar.
  \item \textbf{Simplificar AST}: (Arrumar) Serve para facilitar o trabalho e aplicar fragmentos diretamente na consulta.
  \item \textbf{Transformar AST}: (Arrumar) Serve para adicionar campos a mais, em adaptadores, podem ser usados para adicionar campos a mais. Este processo pode ser sobrescrito por adaptadores.
  \item \textbf{Reduzir ASTs}: (Arrumar) Serve para analisar todos os ASTs, classificar por heuristicas baseadas em tamanho de dados retornado e requisições.
  \item \textbf{Desfazer envoltório de AST}: (Arrumar) Serve para poder realizar a consulta certa em busca dos dados do serviço.
  \item \textbf{Buscar de dados}: (Arrumar) Serve para interpretar o AST e requisições para a API do serviço. Este processo pode ser sobrescrito por adaptadores.
  \item \textbf{Criar envoltório de dados}: (Arrumar) Serve para remapear os campos para o formato que o esquema vai entender.
  \item \textbf{Unificar dados}: (Arrumar) Serve para juntar profundamente todos os dados retornados de cada serviço.
\end{enumerate}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \begin{pgfonlayer}{background}
      \path[rounded corners, draw=black!50, dashed] (-5.2,0) rectangle (5.2,5);
    \end{pgfonlayer}
    \node (serviceDots) at (-4,2.5) {\vdots};
    \node [circle, draw, above of=serviceDots,node distance=1.5cm,font=\footnotesize] (service1) {$Service_1$};
    \node [circle, draw, below of=serviceDots,node distance=1.5cm,font=\footnotesize] (serviceN) {$Service_N$};
    \node [right of=serviceDots,node distance=2cm] (schemaDots) {\vdots};
    \node [above of=schemaDots,node distance=1.5cm] (schema1) {$Schema_1$};
    \node [below of=schemaDots,node distance=1.5cm] (schemaN) {$Schema_N$};
    \node [right of=schemaDots,node distance=2cm] (wrappedSchemaDots) {\vdots};
    \node [above of=wrappedSchemaDots,node distance=1.5cm] (wrappedSchema1) {$Schema_1$};
    \node [below of=wrappedSchemaDots,node distance=1.5cm] (wrappedSchemaN) {$Schema_N$};
    \node [rectangle,draw,minimum width=0.6cm,font=\footnotesize,right of=wrappedSchemaDots,node distance=2cm] (deepExtendSchema) {$3$};
    \node [circle,draw,right of=deepExtendSchema,node distance=2cm] (schema) {$Schema$};
    \draw [->] (service1) -- (schema1) node [midway,above,font=\footnotesize] {$1$};
    \draw [->] (serviceN) -- (schemaN) node [midway,above,font=\footnotesize] {$1$};
    \draw [->] (schema1) -- (wrappedSchema1) node [midway,above,font=\footnotesize] {$2$};
    \draw [->] (schemaN) -- (wrappedSchemaN) node [midway,above,font=\footnotesize] {$2$};
    \draw [->] (wrappedSchema1) -- (deepExtendSchema);
    \draw [->] (wrappedSchemaN) -- (deepExtendSchema);
    \draw [->] (deepExtendSchema) -- (schema);
  \end{tikzpicture}
  \caption{Processo de criação do intermediador}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \begin{pgfonlayer}{background}
      \path[rounded corners, draw=black!50, dashed] (-5.2,0) rectangle (5.2,5);
    \end{pgfonlayer}
    \node [circle, draw] (ast) at (-4.5,2.5) {$AST$};
    \node [right of=ast,node distance=1.5cm] (astTransformedDots) {\vdots};
    \node [above of=astTransformedDots,node distance=1.5cm] (astTransformed1) {$AST_1$};
    \node [below of=astTransformedDots,node distance=1.5cm] (astTransformedN) {$AST_N$};
    \node [rectangle,draw,minimum width=0.6cm,font=\footnotesize,right of=astTransformedDots,node distance=1.5cm] (reduceASTs) {$6$};
    \node [right of=reduceASTs,node distance=1.5cm] (unwrappedASTDots) {\vdots};
    \node [above of=unwrappedASTDots,node distance=1.5cm] (unwrappedAST1) {$AST_1$};
    \node [below of=unwrappedASTDots,node distance=1.5cm] (unwrappedASTN) {$AST_N$};
    \node [right of=unwrappedASTDots,node distance=1.5cm] (dataDots) {\vdots};
    \node [above of=dataDots,node distance=1.5cm] (data1) {$Data_1$};
    \node [below of=dataDots,node distance=1.5cm] (dataN) {$Data_N$};
    \node [rectangle,draw,minimum width=0.6cm,font=\footnotesize,right of=dataDots,node distance=1.5cm] (deepExtendData) {$10$};
    \node [circle, draw,right of=deepExtendData,node distance=1.5cm] (data) {$Data$};
    \draw [->,min distance=3cm,font=\footnotesize] (ast) edge[loop above] node {$4$} (ast);
    \draw [->] (ast) -- (astTransformed1) node [midway,above,font=\footnotesize] {$5$};
    \draw [->] (ast) -- (astTransformedN) node [midway,above,font=\footnotesize] {$5$};
    \draw [->] (astTransformed1) -- (reduceASTs);
    \draw [->] (astTransformedN) -- (reduceASTs);
    \draw [->] (reduceASTs) -- (unwrappedAST1) node [midway,above,font=\footnotesize] {$7$};
    \draw [->] (reduceASTs) -- (unwrappedASTN) node [midway,above,font=\footnotesize] {$7$};
    \draw [->] (unwrappedAST1) -- (data1) node [midway,above,font=\footnotesize] {$8$};
    \draw [->] (unwrappedASTN) -- (dataN) node [midway,above,font=\footnotesize] {$8$};
    \draw [->] (data1) -- (deepExtendData) node [midway,above,font=\footnotesize] {$9$};
    \draw [->] (dataN) -- (deepExtendData) node [midway,above,font=\footnotesize] {$9$};
    \draw [->] (deepExtendData) -- (data);
  \end{tikzpicture}
  \caption{Processo de consulta de dados no intermediador}
\end{figure}

O processo de criação do intermediador começa através da resolução de cada função de configuração\footnote{
  URL, metadados, adaptador e definições de envoltório.
} de serviço e construído um esquema GraphQL interno para cada um. Logo mais, é aplicado o envoltório dos campos dos esquemas e, para cada um, estende-se até gerar um esquema GraphQL unificado.

O processo de consulta de dados no intermediador começa através de uma chamada de consulta no esquema gerado. Primeiro utiliza-se o AST fornecido pela função de resolução de consulta GraphQL e converte-se para uma estrutura de maior facilidade de trabalho. Em seguida, transforma-se o AST já simplificado em ASTs específicos para o esquema de cada serviço. Durante esse processo, reduz-se as árvores através de um algoritmo de otimização de busca que analisa o conjunto como um todo. Por fim, para se poder realizar a busca de dados correspondente em cada serviço, é desfeito o envoltório dos ASTs, realizadas as requisições e criado o envoltório e união dos dados JSON retornados. \\
