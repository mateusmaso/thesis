\section{Planejamento de Projeto}

Este tópico analisa o contexto do problema que deu origem ao processo de idealização, a proposta do modelo de comunicação e a especificação da ferramenta. \\

\textbf{Processo de idealização} \\

Para que clientes possam trabalhar com dados remotos, é preciso que haja um meio de buscá-los antes de executar qualquer lógica que dependa deles. Para isso, a solução comumente adotada é a implementação de um código de busca para acesso remoto de dados em APIs de serviços\footnote{
  Infraestrutura distribuída (servidores, banco de dados, etc) que respondem a pedidos de operações oriundas de clientes em forma de requisições de API.
}.

Para que se possa manter garantia na comunicação, ao passar do tempo, fez-se necessário estabelecer um contrato de acesso entre o cliente e a interface do serviço. Isso porque a atual implementação do código de busca por clientes não prevê mudanças na especificação da API. Este contrato é, portanto, representado no modelo de comunicação da figura 16 através de chamadas entre o código de busca do cliente e a API do serviço.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client) at (-3,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[right of=client] (clientFetchCode) at (-2.2,0.7) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=clientFetchCode, node distance=1.6cm] (clientLogicCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[rectangle,minimum width=0.8cm, minimum height=3cm,draw,right of=clientFetchCode, node distance=3.0cm] (api) {$API$};
    \node[right of=api, node distance=1.8cm] (server) {\includegraphics[width=1.0cm]{figuras/server}};
    \node[below of=server, node distance=1.8cm] (datastore) {\includegraphics[width=1.0cm]{figuras/database}};
    \node[above of=server, node distance=1.8cm] (data) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[cloud, cloud puffs=30, minimum width=11cm, minimum height=10cm, draw,style={scale=0.6}] (service) at (server) {};
    \node[below of=clientFetchCode,node distance=0.0cm] {\textless$fetch$\textgreater};
    \node[below of=clientLogicCode,node distance=0.0cm] {\textless$logic$\textgreater};
    \node[below of=data,node distance=0.0cm] {\{$data$\}};
    \node[below of=service,node distance=3.6cm] {$Service$};
    \node[below of=client,node distance=1.8cm] {\ldots};
    \node[right of=server,node distance=1.8cm] {\ldots};
    \draw[decorate,decoration={brace,raise=0.2cm,mirror}] ([yshift=6pt]clientFetchCode.north west) -- ([yshift=-12pt]clientLogicCode.south west);
    \draw [->] ([yshift=0.25cm]clientFetchCode.east) -- ([yshift=0.25cm]api.west);
    \draw [->] (api) -- (clientFetchCode);
  \end{tikzpicture}
  \caption{Modelo de comunicação entre cliente e serviço}
\end{figure}

O modelo de comunicação representado pode não revelar problemas para serviços com pouca demanda de acesso e diversidade de consultas. Contudo, ao longo do tempo e com o aumento na quantidade de contratos, alterações na especificação como, por exemplo, as de fluxo de dados\footnote{
  Fluxo de acesso por clientes para consulta de dados sobre APIs de serviços.
} podem se tornar um desafio.

Mudanças no fluxo de dados pela API são inevitáveis em aplicações distribuídas. Elas ocorrem para abraçar a constante transformação por clientes na execução de consultas de dados. Com isso, busca-se manter uma comunicação eficiente através da redução no número de chamadas executadas na API e do tamanho de dados transmitidos pela rede. Essas mudanças podem ser desde uma simples alteração no nome de um método ou número argumentos, até as mais complexas, como dados de retorno e estilo de arquitetura. A figura 17 ilustra o fluxo de dados entre um cliente e um serviço.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \draw (-2,0) -- (-2,-5) (2,0) -- (2,-5);
    \node at (-2,0.3) {Client};
    \node at (2,0.3) {API (Service)};
    \node[loosely dotted] (virtualData) at (-4,-1){\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=virtualData,node distance=0.0cm] {\{$data$\}};
    \node (data) at (-4,-4.5) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=data,node distance=0.0cm] {\{$data$\}};
    \node[cloud, cloud puffs=16,draw,minimum height=1.2cm] (cloudData) at (4,-2.5) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=cloudData,node distance=0.0cm] {\{$data$\}};
    \draw[->] (-2,-1) -- node[midway,above] {$request$} (2,-1.5);
    \draw[<-] (-2,-2.5) -- node[midway,above] {$response$} (2,-2);
    \draw[->] (-2,-3) -- node[midway,above] {$request$} (2,-3.5);
    \draw[<-] (-2,-4.5) -- node[midway,above] {$response$} (2,-4);
  \end{tikzpicture}
  \caption{Fluxo de dados entre cliente e API}
\end{figure}

O impacto causado em clientes por mudanças no fluxo de dados de uma API felizmente é previsível, pois afeta diretamente, em sua maioria, o código de busca. Por outro lado, mudanças como a alteração de campos nas estruturas de dados, como renomear um campo "nome" para "nome\_completo", são de um grau de complexidade maior, pois pode não ter impacto no código de busca e sim na lógica da aplicação, onde é bem mais difícil de depurar erros.

Com o objetivo de viabilizar um novo modelo de comunicação a fim de evitar o impacto no código de busca em clientes devido a mudanças no fluxo de dados, fez-se necessário solucionar os seguintes problemas descritos na tabela 5. \\

\begin{table}[H]
  \begin{tabularx}{\linewidth}{>{\parskip1ex}X@{\kern4\tabcolsep}>{\parskip1ex}X}
    \toprule
    \hfil\bfseries Problema
    &
    \hfil\bfseries Solução
    \\\cmidrule(r{3\tabcolsep}){1-1}\cmidrule(l{-\tabcolsep}){2-2}

    (1) Garantir que não haja criação de contrato entre código de busca e API.\par
    (2) Realizar mudanças no fluxo de dados de uma API sem interferir no código de busca dos clientes.\par
    (3) Encontrar uma forma de expressar requisições entre o cliente e o intermediador.\par
    (4) Mapear consultas no intermediador em requisições para API de serviços.\par

    &

    (1) Construir um intermediador responsável por manter a comunicação entre cliente e serviço.\par
	(2) Evitar que clientes escrevam código de busca voltado à especificação da API, e sim para o intermediador.\par
    (3) Usar uma linguagem de consulta para expressar dependência de dados.\par
    (4) Analisar dependência de dados e formas de acesso através de metadados da API de serviços.\par

\\\bottomrule
  \end{tabularx}
  \caption{Problema-solução na concepção do novo modelo}
\end{table}

\textbf{Proposta de modelo} \\

Um novo modelo é proposto com o intuito de melhorar a comunicação cliente-servidor apresentada. Observado na figura 18, este prevê a criação de uma ferramenta no cliente para a intermediação da comunicação entre o código de busca e a API de serviços. Além disso, há a necessidade de reimplementação do código de busca para uma nova linguagem de consulta que seja interpretada pelo intermediador. Da mesma forma, soma-se a criação de um arquivo no serviço para descrição de metadados da API e outro no cliente para configuração, ambos essenciais para o funcionamento da ferramenta.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client) at (-3,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[right of=client] (clientFetchCode) at (-2.2,0) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=clientFetchCode, node distance=1.6cm] (clientLogicCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[above of=clientFetchCode, node distance=1.6cm] (clientConfigCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[rectangle,draw,right of=clientFetchCode,minimum height=1cm,minimum width=1.5cm,node distance=2.0cm] (tool) {$Tool$};
    \node[rectangle,minimum width=0.8cm, minimum height=3cm,draw,node distance=1.8cm,right of=tool,node distance=2.7cm] (api) {$API$};
    \node[right of=api, node distance=1.8cm] (data) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=data,node distance=1.8cm] (server) {\includegraphics[width=1.0cm]{figuras/server}};
    \node[above of=data, node distance=1.8cm] (metadata) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[cloud, cloud puffs=30, minimum width=11cm, minimum height=10cm, draw,style={scale=0.6}] (service) at (data) {};
    \node[below of=clientFetchCode,node distance=0.0cm] {\textless$fetch$\textgreater};
    \node[below of=clientLogicCode,node distance=0.0cm] {\textless$logic$\textgreater};
    \node[below of=clientConfigCode,node distance=0.0cm] {\textless$config$\textgreater};
    \node[below of=metadata,node distance=0.0cm] {\{$metadata$\}};
    \node[below of=data,node distance=0.0cm] {\{$data$\}};
    \node[below of=service,node distance=3.6cm] {$Service$};
    \node[below of=client,node distance=1.8cm] {\vdots};
    \node[right of=data,node distance=1.8cm] {\ldots};
    \draw[decorate,decoration={brace,raise=0.2cm,mirror}] ([yshift=6pt]clientConfigCode.north west) -- ([yshift=-12pt]clientLogicCode.south west);
    \draw [->] ([yshift=0.25cm]clientFetchCode.east) -- ([yshift=0.25cm]tool.west);
    \draw [->] (tool) -- (clientFetchCode);
    \draw [->] ([yshift=0.25cm]tool.east) -- ([yshift=0.25cm]api.west);
    \draw [->] (api) -- (tool);
    \draw [->,dashed] (clientConfigCode) -| ([xshift=-0.25cm]tool.north);
    \draw [->,dashed] (metadata) -| ([xshift=0.25cm]tool.north);
  \end{tikzpicture}
  \caption{Modelo proposto para evitar contrato de comunicação}
\end{figure}

A proposta de eliminação de contrato visa também automatizar o acesso de clientes em APIs. Através da implementação de algoritmos na ferramenta, escolhe-se o caminho de acesso de melhor custo-benefício em relação aos serviços disponíveis para o cliente. O modelo proporciona, além disso, um ambiente escalável para consulta de dados através da composição de serviços, visto na figura 19.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client1) at (-2,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node (client2) at (2,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[rectangle,draw,minimum height=1cm,minimum width=1.5cm,below of=client2,node distance=2.3cm] (tool) {$Tool$};
    \node[cloud, cloud puffs=16, draw] (service1) at (-3,-6) {$Service_1$};
    \node (serviceDots) at (0,-6) {\ldots};
    \node[cloud, cloud puffs=16,minimum height=1cm, draw] (serviceN) at (3,-6) {$Service_N$};
    \draw [->] (client1) -- (service1) node [midway,above,font=\footnotesize] {$request$};
    \draw [->] (client1) -- (serviceN) node [midway,above,font=\footnotesize] {$request$};
    \draw [->] (client2) -- (tool) node [midway,above,font=\footnotesize] {$query$};
    \draw [->] (tool) -- (service1) node [midway,above,font=\footnotesize] {$request$};
    \draw [->] (tool) -- (serviceN) node [midway,above,font=\footnotesize] {$request$};
  \end{tikzpicture}
  \caption{Composição de serviços através da ferramenta}
\end{figure}

\textbf{Especificação da ferramenta} \\

Visando a aceitação da ferramenta prevista pelo modelo em ambientes de desenvolvimento de clientes, foi preciso pensar em uma especificação que apresentasse uma interface de baixa curva de aprendizagem, um fluxo de execução replicável e agnóstico à plataforma, além do baixo impacto na base de código de clientes. Por conseguinte, a ferramenta proposta foi desenvolvida pensando na reutilização de tecnologias promissoras ou bem consolidadas no mercado de desenvolvimento.

Com a sucessão de estudos, a primeira escolha foi utilizar a tecnologia GraphQL como principal solução para intermediação na comunicação. Além de promover seu uso, o GraphQL é a base para os demais fluxos de execução da ferramenta e possibilita que clientes escrevam um código de busca que não fique preso a uma interface de acesso. Da mesma forma, buscou-se trabalhar com formatos abertos de descrição de metadados de APIs, como por exemplo o JSON Hyper-Schema. Através de adaptadores, a ferramenta permite acelerar a integração de serviços que já oferecem metadados em formatos suportados.

A seguir, é realizada a análise dos dois fluxos de execução descritos na especificação da ferramenta. O primeiro, ilustrado na figura 20, é o processo de criação do intermediador, que recebe de entrada funções de configuração de serviços e retorna um esquema GraphQL. O segundo, mostrado na figura 21, é o processo de consulta de dados no intermediador, que recebe de entrada consultas escritas na sintaxe da linguagem GraphQL e, após chamadas às APIs, retorna estruturas de dados JSON.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \begin{pgfonlayer}{background}
      \path[rounded corners, draw=black!50, dashed] (-5.2,0) rectangle (5.2,5);
    \end{pgfonlayer}
    \node (serviceDots) at (-4,2.5) {\vdots};
    \node [circle, draw, above of=serviceDots,node distance=1.5cm,font=\footnotesize] (service1) {$Service_1$};
    \node [circle, draw, below of=serviceDots,node distance=1.5cm,font=\footnotesize] (serviceN) {$Service_N$};
    \node [right of=serviceDots,node distance=2cm] (schemaDots) {\vdots};
    \node [above of=schemaDots,node distance=1.5cm] (schema1) {$Schema_1$};
    \node [below of=schemaDots,node distance=1.5cm] (schemaN) {$Schema_N$};
    \node [right of=schemaDots,node distance=2cm] (wrappedSchemaDots) {\vdots};
    \node [above of=wrappedSchemaDots,node distance=1.5cm] (wrappedSchema1) {$Schema_1$};
    \node [below of=wrappedSchemaDots,node distance=1.5cm] (wrappedSchemaN) {$Schema_N$};
    \node [rectangle,draw,minimum width=0.6cm,font=\footnotesize,right of=wrappedSchemaDots,node distance=2cm] (deepExtendSchema) {$3$};
    \node [circle,draw,right of=deepExtendSchema,node distance=2cm] (schema) {$Schema$};
    \draw [->] (service1) -- (schema1) node [midway,above,font=\footnotesize] {$1$};
    \draw [->] (serviceN) -- (schemaN) node [midway,above,font=\footnotesize] {$1$};
    \draw [->] (schema1) -- (wrappedSchema1) node [midway,above,font=\footnotesize] {$2$};
    \draw [->] (schemaN) -- (wrappedSchemaN) node [midway,above,font=\footnotesize] {$2$};
    \draw [->] (wrappedSchema1) -- (deepExtendSchema);
    \draw [->] (wrappedSchemaN) -- (deepExtendSchema);
    \draw [->] (deepExtendSchema) -- (schema);
  \end{tikzpicture}
  \caption{Processo de criação do intermediador}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \begin{pgfonlayer}{background}
      \path[rounded corners, draw=black!50, dashed] (-5.2,0) rectangle (5.2,5);
    \end{pgfonlayer}
    \node [circle, draw] (ast) at (-4.5,2.5) {$AST$};
    \node [right of=ast,node distance=1.5cm] (astTransformedDots) {\vdots};
    \node [above of=astTransformedDots,node distance=1.5cm] (astTransformed1) {$AST_1$};
    \node [below of=astTransformedDots,node distance=1.5cm] (astTransformedN) {$AST_N$};
    \node [rectangle,draw,minimum width=0.6cm,font=\footnotesize,right of=astTransformedDots,node distance=1.5cm] (reduceASTs) {$6$};
    \node [right of=reduceASTs,node distance=1.5cm] (unwrappedASTDots) {\vdots};
    \node [above of=unwrappedASTDots,node distance=1.5cm] (unwrappedAST1) {$AST_1$};
    \node [below of=unwrappedASTDots,node distance=1.5cm] (unwrappedASTN) {$AST_N$};
    \node [right of=unwrappedASTDots,node distance=1.5cm] (dataDots) {\vdots};
    \node [above of=dataDots,node distance=1.5cm] (data1) {$Data_1$};
    \node [below of=dataDots,node distance=1.5cm] (dataN) {$Data_N$};
    \node [rectangle,draw,minimum width=0.6cm,font=\footnotesize,right of=dataDots,node distance=1.5cm] (deepExtendData) {$10$};
    \node [circle, draw,right of=deepExtendData,node distance=1.5cm] (data) {$Data$};
    \draw [->,min distance=3cm,font=\footnotesize] (ast) edge[loop above] node {$4$} (ast);
    \draw [->] (ast) -- (astTransformed1) node [midway,above,font=\footnotesize] {$5$};
    \draw [->] (ast) -- (astTransformedN) node [midway,above,font=\footnotesize] {$5$};
    \draw [->] (astTransformed1) -- (reduceASTs);
    \draw [->] (astTransformedN) -- (reduceASTs);
    \draw [->] (reduceASTs) -- (unwrappedAST1) node [midway,above,font=\footnotesize] {$7$};
    \draw [->] (reduceASTs) -- (unwrappedASTN) node [midway,above,font=\footnotesize] {$7$};
    \draw [->] (unwrappedAST1) -- (data1) node [midway,above,font=\footnotesize] {$8$};
    \draw [->] (unwrappedASTN) -- (dataN) node [midway,above,font=\footnotesize] {$8$};
    \draw [->] (data1) -- (deepExtendData) node [midway,above,font=\footnotesize] {$9$};
    \draw [->] (dataN) -- (deepExtendData) node [midway,above,font=\footnotesize] {$9$};
    \draw [->] (deepExtendData) -- (data);
  \end{tikzpicture}
  \caption{Processo de consulta de dados no intermediador}
\end{figure}

Os passos enumerados nas figuras 20 e 21 são descritos a seguir:

\begin{enumerate}
  \item Constrói um esquema GraphQL para o serviço através de seus metadados. Este processo pode ser sobrescrito por adaptadores.
  \item Envolve os campos do esquema GraphQL gerado para o serviço visando facilitar a consulta e, depois, unificar com outros esquemas de maneira correta.
  \item Realiza a união dos esquemas GraphQL gerados para cada serviço. Cria um esquema unificado para que a ferramenta possa interpretar consultas de diversos serviços em uma única operação.
  \item Simplifica o AST gerado pela consulta no esquema unificado para facilitar o trabalho na resolução de fragmentos GraphQL.
  \item Transforma o AST principal da consulta em um AST especifico para cada esquema de serviço. Dessa forma, separa os dados que cada serviço consegue disponibilizar para o cliente. Este processo pode ser sobrescrito por adaptadores.
  \item Analisa os ASTs gerados para cada serviço na etapa de transformação e, a partir de heurísticas, reduz os campos dos ASTs para otimizar consultas. A heurística envolve o número de requisições necessárias para número de dados retornados e requisições para obtê-los.
  \item Desfaz o envoltório do AST para poder realizar a requisição correta na consulta dos dados do serviço.
  \item Busca os dados a partir do AST, onde interpreta os metadados do serviço e realiza requisições para a API do serviço. Este processo pode ser sobrescrito por adaptadores.
  \item Recria o envoltório dos dados retornados para que o esquema GraphQL entenda e consiga unificar com outros dados de maneira correta.
  \item Unifica os dados retornados pelas APIs de cada serviço, nas quais foram feitas as requisições.
\end{enumerate}

Em resumo, o processo de criação do intermediador começa através da resolução das funções de configuração de serviços (URL, metadados, adaptador e definições de envoltório) para construir um esquema GraphQL de cada um. Na sequência, é aplicado o envoltório dos campos dos esquemas, estendendo-se até gerar um esquema GraphQL unificado.

Com relação ao processo de consulta de dados no intermediador, este começa através de uma chamada de consulta no esquema gerado. Primeiramente utiliza-se o AST fornecido pela função de resolução de consulta GraphQL e converte-se para uma estrutura de maior facilidade de trabalho. Em seguida, transforma-se o AST já simplificado em ASTs específicos para o esquema de cada serviço. Durante esse processo, reduz-se as árvores através de um algoritmo de otimização de busca que analisa o conjunto como um todo. Por fim, para se poder realizar a consulta de dados correspondente em cada serviço, é desfeito o envoltório dos ASTs, são realizadas as requisições, é criado o envoltório e é feita a união dos dados JSON retornados. \\
