\section{Planejamento de Projeto}

Para melhor entender as etapas de desenvolvimento, antes é preciso conhecer o contexto do problema que deu origem ao processo de idealização, proposta de modelo, além de detalhes na especificação da ferramenta baseado no modelo proposto, como interface e fluxo de execução. \\

\textbf{Processo de idealização} \\

Atualmente, para que clientes façam o uso remoto de estruturas de dados, estes precisam encontrar um meio de buscá-los eventualmente antes de executar uma lógica que dependa dos dados. Isso sugere a escrita de um código encarregado de acessar serviços\footnote{
  Infraestrutura distribuída (servidores, banco de dados, etc) que responde à pedidos de operações oriundas de clientes em forma de requisições de API.
} em busca de dados pela rede.

No entanto, para que haja garantia na comunicação, cria-se um contrato de acesso entre o cliente e a interface do serviço para a busca de dados em pontos de acesso\footnote{
  Parte de uma interface exposta por um serviço através de um canal de comunicação.
} da API. Isso porque, após a implementação do código de busca, é preciso uma garantia de que não haja mudanças na interface que ponham em risco a funcionalidade do cliente e, assim, possivelmente comprometer parte da lógica da aplicação. Este contrato é representado no modelo de comunicação da figura 17 através das chamadas entre o código de busca do cliente e API do serviço.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client) at (-3,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[right of=client] (clientFetchCode) at (-2.2,0.7) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=clientFetchCode, node distance=1.6cm] (clientLogicCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[rectangle,minimum width=0.8cm, minimum height=3cm,draw,right of=clientFetchCode, node distance=3.0cm] (api) {API};
    \node[right of=api, node distance=1.8cm] (server) {\includegraphics[width=1.0cm]{figuras/server}};
    \node[below of=server, node distance=1.8cm] (datastore) {\includegraphics[width=1.0cm]{figuras/database}};
    \node[above of=server, node distance=1.8cm] (json) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[cloud, cloud puffs=30, minimum width=11cm, minimum height=10cm, draw,style={scale=0.6}] (service) at (server) {};
    \node[below of=clientFetchCode,node distance=0.0cm] {\textless$busca$\textgreater};
    \node[below of=clientLogicCode,node distance=0.0cm] {\textless$logica$\textgreater};
    \node[below of=json,node distance=0.0cm] {\{data\}};
    \node[below of=service,node distance=3.6cm] {Serviço};
    \node[below of=client,node distance=1.8cm] {\ldots};
    \node[right of=server,node distance=1.8cm] {\ldots};
    \draw[decorate,decoration={brace,raise=0.2cm,mirror}] ([yshift=6pt]clientFetchCode.north west) -- ([yshift=-12pt]clientLogicCode.south west);
    \draw [->] ([yshift=0.25cm]clientFetchCode.east) -- ([yshift=0.25cm]api.west);
    \draw [->] (api) -- (clientFetchCode);
  \end{tikzpicture}
  \caption{Atual modelo de comunicação entre cliente e serviço}
\end{figure}

O atual modelo de comunicação pode não apresentar problemas visíveis para serviços com pouca demanda de dados de clientes. Contudo, ao longo do tempo e com aumento no número de contratos, mudanças na interface de acesso de serviços são necessárias para facilitar, flexibilizar e/ou otimizar o fluxo de dados\footnote{
  Fluxo de acesso na interface pelo cliente em busca de dados no serviço.
} da API em clientes. Esse tipo de mudança pode ser de caráter pequeno, como o a alteração no nome de um método ou número argumentos, até mudanças mais drásticas como a alteração de dados de retorno e estilo de arquitetura. A figura 18 mostra um exemplo de fluxo de dados que um cliente precisou executar em busca de dados remotos na API de um serviço.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \draw (-2,0) -- (-2,-5) (2,0) -- (2,-5);
    \node at (-2,0.3) {Cliente};
    \node at (2,0.3) {API (Serviço)};
    \node[dashed] (virtualData) at (-4,-1){\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=virtualData,node distance=0.0cm] {\{data\}};
    \node (data) at (-4,-4.5) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=data,node distance=0.0cm] {\{data\}};
    \node[cloud, cloud puffs=16,draw,minimum height=1.2cm] (cloudData) at (4,-2.5) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=cloudData,node distance=0.0cm] {\{data\}};
    \draw[->] (-2,-1) -- node[midway,above] {requisição} (2,-1.5);
    \draw[<-] (-2,-2.5) -- node[midway,above] {resposta} (2,-2);
    \draw[->] (-2,-3) -- node[midway,above] {requisição} (2,-3.5);
    \draw[<-] (-2,-4.5) -- node[midway,above] {resposta} (2,-4);
  \end{tikzpicture}
  \caption{Exemplo de fluxo de dados entre cliente e API}
\end{figure}

Felizmente, o impacto de mudanças de fluxo de dados em clientes são previsíveis, pois afetam em sua maioria o código de busca. Já mudanças como a alteração de campos da estrutura de dados são de um grau de complexidade maior, pois seu impacto vai além do código de busca, podendo estar presente na lógica da aplicação.

Com o objetivo de evitar o impacto de mudanças no fluxo de dados em código de busca dos clientes e viabilizar um novo modelo de comunicação, fez-se necessário solucionar os seguintes problemas descritos pela tabela 5. \\

\begin{table}[H]
  \begin{tabularx}{\linewidth}{>{\parskip1ex}X@{\kern4\tabcolsep}>{\parskip1ex}X}
    \toprule
    \hfil\bfseries Problema
    &
    \hfil\bfseries Solução
    \\\cmidrule(r{3\tabcolsep}){1-1}\cmidrule(l{-\tabcolsep}){2-2}

    (1) Garantir que não haja criação de contrato entre código de busca e API.\par
    (2) Realizar mudanças no fluxo de dados de uma API sem interferir no código de busca de clientes.\par
    (3) Encontrar uma forma de expressar requisições entre o cliente e o intermediador.\par
    (4) Encontrar uma estrutura para analisar consultas.\par
    (5) Mapear consultas em formato AST em requisições de API.\par

    &

    (1) Construir um intermediador responsável por manter a comunicação entre cliente e serviço.\par
	(2) Evitar que clientes escrevam código de busca voltado à especificação da API, e sim para o intermediador.\par
    (3) Usar uma linguagem de consulta para expressar dependência de dados.\par
    (4) Converter consultas em formato AST.\par
    (5) Analisar metadados da API e formas de acesso para a estrutura AST.\par

    \\\bottomrule
  \end{tabularx}
  \caption{Problema e Solução}
\end{table}

\textbf{Proposta de modelo} \\

A fim de melhorar o atual modelo de comunicação cliente-servidor, é proposto um novo modelo pela figura 19, que prevê a criação de uma ferramenta na plataforma do cliente para a intermediação na comunicação entre o código de busca do cliente e API do serviço. Além disso, ocorre a reimplementação do código de busca para a linguagem de consulta que o intermediador entenda, assim como um arquivo disponibilizado pelo serviço para descrição dos metadados de sua API e outro no cliente para configuração, ambos essenciais para o funcionamento do intermediador.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client) at (-3,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[right of=client] (clientFetchCode) at (-2.2,0) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=clientFetchCode, node distance=1.6cm] (clientLogicCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[above of=clientFetchCode, node distance=1.6cm] (clientConfigCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[circle,draw,right of=clientFetchCode,node distance=2.3cm] (broker) {Intermediador};
    \node[rectangle,minimum width=0.8cm, minimum height=3cm,draw,node distance=1.8cm,right of=broker,node distance=2.7cm] (api) {API};
    \node[right of=api, node distance=1.8cm] (json) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=json,node distance=1.8cm] (server) {\includegraphics[width=1.0cm]{figuras/server}};
    \node[above of=json, node distance=1.8cm] (description) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[cloud, cloud puffs=30, minimum width=11cm, minimum height=10cm, draw,style={scale=0.6}] (service) at (json) {};
    \node[below of=clientFetchCode,node distance=0.0cm] {\textless$busca$\textgreater};
    \node[below of=clientLogicCode,node distance=0.0cm] {\textless$logica$\textgreater};
    \node[below of=clientConfigCode,node distance=0.0cm] {\textless$config$\textgreater};
    \node[below of=description,node distance=0.0cm] {\{desc\}};
    \node[below of=json,node distance=0.0cm] {\{data\}};
    \node[below of=service,node distance=3.6cm] {Serviço};
    \node[below of=client,node distance=1.8cm] {\ldots};
    \node[right of=json,node distance=1.8cm] {\ldots};
    \draw[decorate,decoration={brace,raise=0.2cm,mirror}] ([yshift=6pt]clientConfigCode.north west) -- ([yshift=-12pt]clientLogicCode.south west);
    \draw [->] ([yshift=0.25cm]clientFetchCode.east) -- ([yshift=0.25cm]broker.west);
    \draw [->] (broker) -- (clientFetchCode);
    \draw [->] ([yshift=0.25cm]broker.east) -- ([yshift=0.25cm]api.west);
    \draw [->] (api) -- (broker);
    \draw [->,dashed] (clientConfigCode) -| ([xshift=-0.25cm]broker.north);
    \draw [->,dashed] (description) -| ([xshift=0.25cm]broker.north);
  \end{tikzpicture}
  \caption{Modelo proposto para evitar contrato de comunicação}
\end{figure}

O modelo também visa otimizar a busca de dados de clientes através da possibilidade de implementação de algoritmos na ferramenta que direcionam o acesso em APIs de serviços baseado no menor tamanho na resposta de dados e número requisições em pontos de acesso. Além disso, propõe um ambiente escalável para a composição de dados através de serviços, visto na figura 20.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client1) at (-2,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node (client2) at (2,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[circle,draw,below of=client2,node distance=2.3cm] (tool) {Ferramenta};
    \node[cloud, cloud puffs=16, draw] (service1) at (-3,-6) {Serviço 1};
    \node[cloud, cloud puffs=16, draw] (service2) at (0,-6) {Serviço 2};
    \node[cloud, cloud puffs=16, draw] (service3) at (3,-6) {Serviço 3};
    \node[right of=service3,node distance=2.8cm] {\ldots};
    \draw [<->] (client1) -- (service1);
    \draw [<->] (client1) -- (service2);
    \draw [<->] (client1) -- (service3);
    \draw [<->] (client2) -- (tool);
    \draw [<->] (tool) -- (service1);
    \draw [<->] (tool) -- (service2);
    \draw [<->] (tool) -- (service3);
  \end{tikzpicture}
  \caption{Composição de serviços com a ferramenta do modelo proposto}
\end{figure}

\textbf{Especificação de ferramenta baseado no modelo proposto} \\

Para aumentar as chances de aceitação do modelo por desenvolvedores, foi preciso pensar em uma especificação de ferramenta que apresente uma interface de baixa curva de aprendizagem, um fluxo de execução replicável/agnóstico à plataforma e, acima de tudo, cause pouco impacto na base de código de clientes. Por isso, a ferramenta proposta neste projeto foi desenvolvida pensando em reutilizar tecnologias promissoras ou bem consolidadas no mercado de desenvolvimento.

A primeira ideia foi estudar o uso da tecnologia GraphQL como principal linguagem para intermediação na comunicação. Além de promover, a tecnologia é base para os demais fluxos de execução e possibilita que clientes escrevam um código de busca que também funcione em APIs GraphQL sem a ferramenta. O outro caso foi em trabalhar com formatos abertos de descrição de APIs, como por exemplo o JSON Schema. Através de adaptadores, a ferramenta permite acelerar a integração com serviços que já oferecem soluções de descrição de suas APIs.

A seguir é feito a análise dos dois fluxos de execução descritos pela especificação da ferramenta. O primeiro, visto na figura 21, é o processo criação do intermediador, que recebe como entrada funções de configuração de serviços e retorna um esquema GraphQL. O segundo, visto na figura 22, é o processo de consulta de dados no intermediador, onde leva como entrada consultas escritas na sintaxe da linguagem GraphQL e, após chamadas à APIs, retorna estruturas de dados JSON.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small,text width=5em, text centered]
    \node [rectangle,draw,minimum height=4em] (composeSchema) {Compor esquema unificado};
    \node [ellipse,draw,draw, above of=composeSchema,node distance=2cm] (services) {Serviços};
    \node [rectangle,draw,minimum height=4em, right of=composeSchema,node distance=3cm] (buildSchema) {Construir esquema para cada serviço};
    \node [rectangle,draw,minimum height=4em, right of=buildSchema,node distance=3cm] (wrapSchema) {Invólucrar campos de cada esquema};
    \node [rectangle,draw,minimum height=4em, right of=wrapSchema,node distance=3cm] (deepExtendSchema) {Unificar todos os esquemas};
    \node [ellipse,draw, above of=deepExtendSchema,node distance=2cm] (schema) {Esquema};
    \draw [->] (composeSchema) -- (buildSchema);
    \draw [->] (buildSchema) -- (wrapSchema);
    \draw [->] (wrapSchema) -- (deepExtendSchema);
    \draw [->,dashed] (services) -- (composeSchema);
    \draw [->,dashed] (deepExtendSchema) -- (schema);
  \end{tikzpicture}
  \caption{Criação do intermediador (esquema)}
\end{figure}
 
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small,text width=5em, text centered]
    \node [rectangle,draw,minimum height=4em] (simplifyAST) {Simplificar AST};
    \node [ellipse,draw, above of=simplifyAST,node distance=2cm] (services) {Consulta};
    \node [rectangle,draw,minimum height=4em, below of=simplifyAST,node distance=2cm] (transformAST) {Transformar AST para cada serviço};
    \node [rectangle,draw,minimum height=4em, right of=transformAST,node distance=3cm] (reduceASTs) {Reduzir AST de cada serviço};
    \node [rectangle,draw,minimum height=4em, right of=reduceASTs,node distance=3cm] (unwrapAST) {Desfazer invólucro de cada AST};
    \node [rectangle,draw,minimum height=4em, right of=unwrapAST,node distance=3cm] (fetchData) {Realizar busca dados para cada serviço};
    \node [rectangle,draw,minimum height=4em, above of=fetchData,node distance=2cm] (wrapData) {Invólucrar e unificar dados};
    \node [ellipse,draw, above of=wrapData,node distance=2cm] (schema) {Dados};
    \draw [->] (simplifyAST) -- (transformAST);
    \draw [->] (transformAST) -- (reduceASTs);
    \draw [->] (reduceASTs) -- (unwrapAST);
    \draw [->] (unwrapAST) -- (fetchData);
    \draw [->] (fetchData) -- (wrapData);
    \draw [->,dashed] (services) -- (simplifyAST);
    \draw [->,dashed] (wrapData) -- (schema);
  \end{tikzpicture}
  \caption{Consulta de dados no intermediador (esquema)}
\end{figure}

O processo de criação do intermediador começa resolvendo cada função de configuração de serviço e construindo um esquema GraphQL para cada um. Após, é feito o invólucro dos campos de cada esquema e para cada um estende-se até gerar um esquema GraphQL unificado.

O processo de consulta de dados no intermediador começa através de uma chamada de consulta GraphQL no esquema GraphQL unificado. Primeiro é convertido a estrutura AST em um formato mais simplificado para se trabalhar. Após, transforma-se o AST principal em um AST especifico para cada serviço. Com as árvores de consulta, é feito a redução aplicando-se um algoritmo de otimização de busca. Após, é desfeito o invólucro de cada AST para poder realizar a busca de dados no serviço correspondente. Por fim, ao retornar os dados, realiza-se novamente o invólucro e estende-se cada dado até gerar um dado unificado.