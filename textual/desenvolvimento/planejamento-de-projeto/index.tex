\section{Planejamento de Projeto}

Para um melhor entendimento das etapas de desenvolvimento, antes é preciso conhecer o contexto do problema que deu origem ao processo de idealização, proposta de modelo, além de detalhes na especificação da ferramenta baseado no modelo proposto, como interface e fluxo de execução. \\

\textbf{Processo de idealização} \\

Atualmente, para que clientes possam consumir dados remotos, é preciso que haja um meio de buscá-los antes de executar qualquer lógica que dependa deles. Para isso, é preciso a implementação de um código de busca para acesso à dados em serviços\footnote{
  Infraestrutura distribuída (servidores, banco de dados, etc) que respondem a pedidos de operações oriundas de clientes em forma de requisições de API.
} através de uma rede.

No entanto, para que se possa manter garantia na comunicação, é necessário um contrato de acesso entre o cliente e a interface do serviço. Isso porque, após a implementação do código de busca pelo cliente, qualquer mudança em pontos de acesso\footnote{
  Parte de uma interface exposta por um serviço através de um canal de comunicação.
} da API podem colocar em risco sua funcionalidade e comprometer parte da lógica da aplicação. Este contrato é, portanto, representado no modelo de comunicação da figura 17 através das chamadas entre o código de busca do cliente e API do serviço.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client) at (-3,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[right of=client] (clientFetchCode) at (-2.2,0.7) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=clientFetchCode, node distance=1.6cm] (clientLogicCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[rectangle,minimum width=0.8cm, minimum height=3cm,draw,right of=clientFetchCode, node distance=3.0cm] (api) {API};
    \node[right of=api, node distance=1.8cm] (server) {\includegraphics[width=1.0cm]{figuras/server}};
    \node[below of=server, node distance=1.8cm] (datastore) {\includegraphics[width=1.0cm]{figuras/database}};
    \node[above of=server, node distance=1.8cm] (json) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[cloud, cloud puffs=30, minimum width=11cm, minimum height=10cm, draw,style={scale=0.6}] (service) at (server) {};
    \node[below of=clientFetchCode,node distance=0.0cm] {\textless\textit{busca}\textgreater};
    \node[below of=clientLogicCode,node distance=0.0cm] {\textless\textit{lógica}\textgreater};
    \node[below of=json,node distance=0.0cm] {\{dados\}};
    \node[below of=service,node distance=3.6cm] {Serviço};
    \node[below of=client,node distance=1.8cm] {\ldots};
    \node[right of=server,node distance=1.8cm] {\ldots};
    \draw[decorate,decoration={brace,raise=0.2cm,mirror}] ([yshift=6pt]clientFetchCode.north west) -- ([yshift=-12pt]clientLogicCode.south west);
    \draw [->] ([yshift=0.25cm]clientFetchCode.east) -- ([yshift=0.25cm]api.west);
    \draw [->] (api) -- (clientFetchCode);
  \end{tikzpicture}
  \caption{Modelo de comunicação entre cliente e serviço.}
\end{figure}

O modelo de comunicação representado pode não revelar possíveis problemas para serviços com pouca demanda de dados e diversidade de clientes. Contudo, ao longo do tempo, com o aumento na quantidade de contratos, mudanças podem se tornar difíceis, como, por exemplo, as de fluxo de dados\footnote{
  Fluxo de acesso na interface pelo cliente em busca de dados no serviço.
} nas interfaces de acesso. 

Mudanças no fluxo de dados são inevitáveis em aplicações distribuídas. Elas ocorrem para abraçar a constante transformação na demanda de dados por clientes. Com isso, busca-se manter uma comunicação eficiente com redução no número de chamadas e tamanho de dados feitas na API. Essas mudanças podem ser desde uma simples alteração no nome de um método ou número argumentos, até as mais complexas como dados de retorno e estilo de arquitetura. A figura 18 mostra um exemplo de fluxo de dados que um cliente executa em busca de dados remotos na API de um serviço.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \draw (-2,0) -- (-2,-5) (2,0) -- (2,-5);
    \node at (-2,0.3) {Cliente};
    \node at (2,0.3) {API (Serviço)};
    \node[loosely dotted] (virtualData) at (-4,-1){\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=virtualData,node distance=0.0cm] {\{dados\}};
    \node (data) at (-4,-4.5) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=data,node distance=0.0cm] {\{dados\}};
    \node[cloud, cloud puffs=16,draw,minimum height=1.2cm] (cloudData) at (4,-2.5) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=cloudData,node distance=0.0cm] {\{dados\}};
    \draw[->] (-2,-1) -- node[midway,above] {requisição} (2,-1.5);
    \draw[<-] (-2,-2.5) -- node[midway,above] {resposta} (2,-2);
    \draw[->] (-2,-3) -- node[midway,above] {requisição} (2,-3.5);
    \draw[<-] (-2,-4.5) -- node[midway,above] {resposta} (2,-4);
  \end{tikzpicture}
  \caption{Fluxo de dados entre cliente e API.}
\end{figure}

Felizmente, o impacto nos clientes com as mudanças no fluxo de dados de uma API são previsíveis, pois afetam diretamente, em sua maioria, o código de busca. Por outro lado, mudanças como a alteração de campos nas estruturas de dados\footnote{
  Exemplo: dada uma entidade pessoa, separar o campo "nome" em dois novos campos como "nome" e "sobrenome".
} são de um grau de complexidade maior, pois seu impacto pode não influenciar o código de busca e sim a lógica da aplicação, onde é bem mais difícil debugar.

Com o objetivo de viabilizar um novo modelo de comunicação a fim de evitar o impacto no código de busca em clientes devido a mudanças no fluxo de dados, fez-se necessário solucionar os seguintes problemas descritos na tabela 5. \\

\begin{table}[H]
  \begin{tabularx}{\linewidth}{>{\parskip1ex}X@{\kern4\tabcolsep}>{\parskip1ex}X}
    \toprule
    \hfil\bfseries Problema
    &
    \hfil\bfseries Solução
    \\\cmidrule(r{3\tabcolsep}){1-1}\cmidrule(l{-\tabcolsep}){2-2}

    (1) Garantir que não haja criação de contrato entre código de busca e API.\par
    (2) Realizar mudanças no fluxo de dados de uma API sem interferir no código de busca dos clientes.\par
    (3) Encontrar uma forma de expressar requisições entre o cliente e o intermediador.\par
    (4) Mapear consultas no intermediador em requisições para API de serviços.\par

    &

    (1) Construir um intermediador responsável por manter a comunicação entre cliente e serviço.\par
	(2) Evitar que clientes escrevam código de busca voltado à especificação da API, e sim para o intermediador.\par
    (3) Usar uma linguagem de consulta para expressar dependência de dados.\par
    (4) Analisar dependência de dados e formas de acesso através de metadados da API de serviços.\par

\\\bottomrule
  \end{tabularx}
  \caption{Problema-solução na concepção do novo modelo.}
\end{table}

\textbf{Proposta de modelo} \\

A fim de melhorar o modelo de comunicação cliente-servidor apresentado, é proposto um novo modelo na figura 19. Ele prevê a criação de uma ferramenta no cliente para a intermediação da comunicação entre o código de busca e API de serviços. Além disso, há a necessidade de reimplementação do código de busca para uma nova linguagem de consulta que seja interpretada pelo intermediador. Da mesma forma, soma-se a criação de um arquivo no serviço para descrição de metadados da API e outro no cliente para configuração, ambos essenciais para o funcionamento do intermediador.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client) at (-3,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[right of=client] (clientFetchCode) at (-2.2,0) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=clientFetchCode, node distance=1.6cm] (clientLogicCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[above of=clientFetchCode, node distance=1.6cm] (clientConfigCode) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[circle,draw,right of=clientFetchCode,node distance=2.3cm] (broker) {Intermediador};
    \node[rectangle,minimum width=0.8cm, minimum height=3cm,draw,node distance=1.8cm,right of=broker,node distance=2.7cm] (api) {API};
    \node[right of=api, node distance=1.8cm] (json) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[below of=json,node distance=1.8cm] (server) {\includegraphics[width=1.0cm]{figuras/server}};
    \node[above of=json, node distance=1.8cm] (metadata) {\includegraphics[width=1.1cm]{figuras/code}};
    \node[cloud, cloud puffs=30, minimum width=11cm, minimum height=10cm, draw,style={scale=0.6}] (service) at (json) {};
    \node[below of=clientFetchCode,node distance=0.0cm] {\textless\textit{busca}\textgreater};
    \node[below of=clientLogicCode,node distance=0.0cm] {\textless\textit{lógica}\textgreater};
    \node[below of=clientConfigCode,node distance=0.0cm] {\textless\textit{config}\textgreater};
    \node[below of=metadata,node distance=0.0cm] {\{metadados\}};
    \node[below of=json,node distance=0.0cm] {\{dados\}};
    \node[below of=service,node distance=3.6cm] {Serviço};
    \node[below of=client,node distance=1.8cm] {\ldots};
    \node[right of=json,node distance=1.8cm] {\ldots};
    \draw[decorate,decoration={brace,raise=0.2cm,mirror}] ([yshift=6pt]clientConfigCode.north west) -- ([yshift=-12pt]clientLogicCode.south west);
    \draw [->] ([yshift=0.25cm]clientFetchCode.east) -- ([yshift=0.25cm]broker.west);
    \draw [->] (broker) -- (clientFetchCode);
    \draw [->] ([yshift=0.25cm]broker.east) -- ([yshift=0.25cm]api.west);
    \draw [->] (api) -- (broker);
    \draw [->,dashed] (clientConfigCode) -| ([xshift=-0.25cm]broker.north);
    \draw [->,dashed] (metadata) -| ([xshift=0.25cm]broker.north);
  \end{tikzpicture}
  \caption{Modelo proposto para evitar contrato de comunicação.}
\end{figure}

Além de propor a eliminação de contrato, o modelo visa também automatizar o acesso de clientes em APIs na busca por dados. Através algoritmos de implementação na ferramenta, é feito a escolha do caminho de acesso de melhor custo benefício em relação aos serviços disponíveis para o cliente. Além disso, o modelo proporciona um ambiente escalável para a composição de dados através de serviços, visto na figura 20.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small]
    \node (client1) at (-2,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node (client2) at (2,0) {\includegraphics[width=1.0cm]{figuras/client}};
    \node[circle,draw,below of=client2,node distance=2.3cm] (tool) {Ferramenta};
    \node[cloud, cloud puffs=16, draw] (service1) at (-3,-6) {Serviço 1};
    \node[cloud, cloud puffs=16, draw] (service2) at (0,-6) {Serviço 2};
    \node[cloud, cloud puffs=16, draw] (service3) at (3,-6) {Serviço 3};
    \node[right of=service3,node distance=2.8cm] {\ldots};
    \draw [<->] (client1) -- (service1);
    \draw [<->] (client1) -- (service2);
    \draw [<->] (client1) -- (service3);
    \draw [<->] (client2) -- (tool);
    \draw [<->] (tool) -- (service1);
    \draw [<->] (tool) -- (service2);
    \draw [<->] (tool) -- (service3);
  \end{tikzpicture}
  \caption{Composição de serviços através da ferramenta do modelo}
\end{figure}

\textbf{Especificação de ferramenta baseado no modelo proposto} \\

Para a aceitação do modelo em ambientes de desenvolvimento de clientes, foi preciso pensar em uma especificação de ferramenta que apresentasse uma interface de baixa curva de aprendizagem, um fluxo de execução replicável e agnóstico à plataforma, além do baixo impacto na base de código de clientes. Por isso, a ferramenta proposta neste projeto foi desenvolvida pensando em reutilizar tecnologias promissoras ou bem consolidadas no mercado de desenvolvimento.

Após um estudo, a primeira escolha foi em utilizar a tecnologia GraphQL como principal solução para intermediação na comunicação. Além de promover o seu uso, GraphQL é a base para os demais fluxos de execução da ferramenta e possibilita que clientes escrevam um código de busca que não fique preso à uma interface de acesso. Da mesma forma, buscou-se trabalhar com formatos abertos de descrição de metadados de APIs, como por exemplo o JSON Schema. Através de adaptadores, a ferramenta permite acelerar a integração de serviços que já oferecem metadados em formatos suportados.

A seguir é feito a análise dos dois fluxos de execução descritos pela especificação da ferramenta. O primeiro, visto na figura 21, é o processo criação do intermediador, que recebe como entrada funções de configuração de serviços e retorna um esquema GraphQL. O segundo, visto na figura 22, é o processo de consulta de dados no intermediador, onde leva como entrada consultas escritas na sintaxe da linguagem GraphQL e, após chamadas à APIs, retorna estruturas de dados JSON.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small,text width=5em, text centered]
    \node [rectangle,draw,minimum height=4em] (composeSchema) {Compor esquema unificado};
    \node [ellipse,draw,draw, above of=composeSchema,node distance=2cm] (services) {Serviços};
    \node [rectangle,draw,minimum height=4em, right of=composeSchema,node distance=3cm] (buildSchema) {Construir esquema para cada serviço};
    \node [rectangle,draw,minimum height=4em, right of=buildSchema,node distance=3cm] (wrapSchema) {Invólucrar campos de cada esquema};
    \node [rectangle,draw,minimum height=4em, right of=wrapSchema,node distance=3cm] (deepExtendSchema) {Unificar todos os esquemas};
    \node [ellipse,draw, above of=deepExtendSchema,node distance=2cm] (schema) {Esquema};
    \draw [->] (composeSchema) -- (buildSchema);
    \draw [->] (buildSchema) -- (wrapSchema);
    \draw [->] (wrapSchema) -- (deepExtendSchema);
    \draw [->,dashed] (services) -- (composeSchema);
    \draw [->,dashed] (deepExtendSchema) -- (schema);
  \end{tikzpicture}
  \caption{Criação do intermediador (esquema)}
\end{figure}
 
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[font=\small,text width=5em, text centered]
    \node [rectangle,draw,minimum height=4em] (simplifyAST) {Simplificar AST};
    \node [ellipse,draw, above of=simplifyAST,node distance=2cm] (services) {Consulta};
    \node [rectangle,draw,minimum height=4em, below of=simplifyAST,node distance=2cm] (transformAST) {Transformar AST para cada serviço};
    \node [rectangle,draw,minimum height=4em, right of=transformAST,node distance=3cm] (reduceASTs) {Reduzir AST de cada serviço};
    \node [rectangle,draw,minimum height=4em, right of=reduceASTs,node distance=3cm] (unwrapAST) {Desfazer invólucro de cada AST};
    \node [rectangle,draw,minimum height=4em, right of=unwrapAST,node distance=3cm] (fetchData) {Realizar busca dados para cada serviço};
    \node [rectangle,draw,minimum height=4em, above of=fetchData,node distance=2cm] (wrapData) {Invólucrar e unificar dados};
    \node [ellipse,draw, above of=wrapData,node distance=2cm] (schema) {Dados};
    \draw [->] (simplifyAST) -- (transformAST);
    \draw [->] (transformAST) -- (reduceASTs);
    \draw [->] (reduceASTs) -- (unwrapAST);
    \draw [->] (unwrapAST) -- (fetchData);
    \draw [->] (fetchData) -- (wrapData);
    \draw [->,dashed] (services) -- (simplifyAST);
    \draw [->,dashed] (wrapData) -- (schema);
  \end{tikzpicture}
  \caption{Consulta de dados no intermediador (esquema)}
\end{figure}

O processo de criação do intermediador começa através da resolução de cada função de configuração\footnote{
  URL, metadados, adaptador e definições de invólucro.
} de serviço e construído um esquema GraphQL interno para cada um. Após, é feito o invólucro dos campos dos esquemas e, para cada um, estende-se até gerar um esquema GraphQL unificado.

O processo de consulta de dados no intermediador começa através de uma chamada de consulta no esquema gerado. Primeiro, usa-se o AST fornecido pela função de resolução de consulta GraphQL e converte-se em uma estrutura mais fácil de se trabalhar. Após, transforma-se o AST já simplificado em ASTs especifico para o esquema de cada serviço. Durante esse processo, é feito a redução das árvores aplicando-se um algoritmo de otimização de busca que analisa o conjunto como um todo. Por fim, para se poder realizar a busca de dados correspondente em cada serviço, é desfeito o invólucro dos ASTs, realizado as requisições e feito o invólucro e união dos dados JSON retornados.
